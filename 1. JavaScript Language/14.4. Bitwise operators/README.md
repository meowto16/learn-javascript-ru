# Побитовые операторы

Побитовые операторы работают следующим образом:

1. Операнды преобразуются в 32-битные целые числа, представленные последовательностью битов. Дробная часть, если она есть, отбрасывается.
2. Для бинарных операторов – каждый бит в первом операнде рассматривается вместе с соответствующим битом второго операнда: первый бит с первым, второй со вторым и т.п. Оператор применяется к каждой паре бит, давая соответствующий бит результата.
3. Получившаяся в результате последовательность бит интерпретируется как обычное число.

## Побитовое И (&)

Выполняет операцию И над каждой парой бит.
Результат `a & b` равен единице только когда оба бита `a` и `b` равны единице.

```text
9 (по осн. 10)
  = 00000000000000000000000000001001 (по осн. 2)
14 (по осн. 10)
  = 00000000000000000000000000001110 (по осн. 2)
                   --------------------------------
14 & 9 (по осн. 10)
  = 00000000000000000000000000001000 (по осн. 2)
  = 8 (по осн. 10)
```

## Побитовое ИЛИ (|)

Выполняет операцию ИЛИ над каждой парой бит. Результат `a | b` равен 1, 
если хотя бы один бит из `a,b` равен 1.

```text
9 (по осн. 10)
  = 00000000000000000000000000001001 (по осн. 2)
14 (по осн. 10)
  = 00000000000000000000000000001110 (по осн. 2)
                   --------------------------------
14 | 9 (по осн. 10)
  = 00000000000000000000000000001111 (по осн. 2)
  = 15 (по осн. 10) 
```

## Исключающее ИЛИ (^)

Выполняет операцию «Исключающее ИЛИ» над каждой парой бит.
`a` Исключающее ИЛИ `b` равно 1, если только `a=1` или только `b=1`, но не оба одновременно `a=b=1`.

```text
9 (по осн. 10)
  = 00000000000000000000000000001001 (по осн. 2)
14 (по осн. 10)
  = 00000000000000000000000000001110 (по осн. 2)
                   --------------------------------
14 ^ 9 (по осн. 10)
  = 00000000000000000000000000000111 (по осн. 2)
  = 7 (по осн. 10)
```

## Побитовое НЕ (~)

Производит операцию НЕ над каждым битом, заменяя его на обратный ему.

```text
 9 (по осн. 10)
  = 00000000000000000000000000001001 (по осн. 2)
               --------------------------------
~9 (по осн. 10)
  = 11111111111111111111111111110110 (по осн. 2)
  = -10 (по осн. 10)
```

## Битовый сдвиг влево (<<)

Оператор `<<` сдвигает первый операнд на указанное число битов влево. 
Лишние биты отбрасываются, справа добавляются нулевые биты.

```text
9 (по осн.10)
  = 00000000000000000000000000001001 (по осн.2)
                  --------------------------------
9 << 2 (по осн.10)
  = 00000000000000000000000000100100 (по осн.2)
  = 36 (по осн.10)
```

> **Левый сдвиг почти равен умножению на 2**
> 
> Битовый сдвиг `<< N` обычно имеет тот же эффект, что и умножение на два N раз, например:
> ```js
> alert( 3 << 1 ); // 6, умножение на 2
> alert( 3 << 2 ); // 12, умножение на 2 два раза
> alert( 3 << 3 ); // 24, умножение на 2 три раза
> ```

## Правый битовый сдвиг, переносящий знак (>>)

```text
-9 (по осн.10)
  = 11111111111111111111111111110111 (по осн.2)
                   --------------------------------
-9 >> 2 (по осн.10)
  = 11111111111111111111111111111101 (по осн.2) = -3 (по осн.10)
```

> **Правый сдвиг почти равен целочисленному делению на 2**
> 
> Битовый сдвиг `>> N` обычно имеет тот же результат, что и целочисленное деление на два N раз:
> ```js
> alert( 100 >> 1 ); // 50, деление на 2
> alert( 100 >> 2 ); // 25, деление на 2 два раза
> alert( 100 >> 3 ); // 12, деление на 2 три раза, целая часть от результата
> ``` 

## >>> (Правый сдвиг с заполнением нулями)

```text
-9 (по осн.10)
  = 11111111111111111111111111110111 (по осн.2)
                    --------------------------------
-9 >>> 2 (по осн.10)
  = 00111111111111111111111111111101 (по осн.2)
  = 1073741821 (по осн.10)
```

## Приоритеты

В JavaScript побитовые операторы `^,` `&,` `|` выполняются после сравнений `==`.

Например, в сравнении `a == b^0` будет сначала выполнено сравнение `a == b`, 
а потом уже операция `^0`, как будто стоят скобки `(a == b)^0`.

Обычно это не то, чего мы хотим. Чтобы гарантировать желаемый порядок, 
нужно ставить скобки: `a == (b^0)`.

## Когда используются

- Округления числа: `(12.34^0) = 12`.
- Проверки на равенство `-1`: `if (~n) { n не -1 }`.
- Упаковки нескольких битовых значений («флагов») в одно значение. 
  Это экономит память и позволяет проверять наличие комбинации флагов одним оператором `&`.
- Других ситуаций, когда нужны битовые маски.