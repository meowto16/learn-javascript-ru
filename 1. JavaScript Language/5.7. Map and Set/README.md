# Map и Set

## Map 

**Map** - это коллекция ключ/значение. 

### Отличия от объекта:

- Ключом может быть любой тип данных
- Ключи не преобразуются в строку
- Порядок ключей всегда хранится в порядке добавления
- Сравнение ключей производится по алгоритму `SameValueZero`. Т.е тоже самое что и `===`, но `NaN` тоже равен `NaN`
- Итерируется по ключам, значениям, вхождениям
- Объект хранит ключи от прототипа, Map только то, что в него положишь
- Для Map не поддерживается `JSON.stringify`
- По производительности - лучше объекта, когда есть частые добавления/удаления ключей.

### Основные методы

- `new Map([iterable])` – создаёт коллекцию.
- `map.set(key, value)` – записывает по ключу `key` значение `value`.
- `map.get(key)` – возвращает значение по ключу или `undefined`, если ключ `key` отсутствует.
- `map.has(key)` – возвращает `true`, если ключ `key` присутствует в коллекции, иначе `false`.
- `map.delete(key)` – удаляет элемент по ключу `key`.
- `map.clear()` – очищает коллекцию от всех элементов.
- `map.size` – возвращает текущее количество элементов.

> Метод `map.set` каждый раз возвращает объект `map`, так что методы можно chain'ить.

### Перебор Map

- `map.keys()` - возвращает итерируемый объект по ключам.
- `map.values()` - возвращает итерируемый объект по значениям.
- `map.entries()` - возвращает итерируемый объект по парам вида `[ключ, значение]`
- `map.forEach` - тот же встроенный метод массивов

## Из Map в объект и обратно

- `Object.entries()` - возвращает массив по парам вида `[ключ, значение]`
- `Object.fromEntries()` - создаёт объект из пар виде `[ключ, значение]`

## Set

**Set** - это "множество" значений, где каждое значение может появляться только один раз

### Основные методы

- `new Set([iterable])` – создаёт `Set`, можно указать перебираемый объект со значениями для инициализации.
- `set.add(value)` – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект `set`.
- `set.delete(value)` – удаляет значение, возвращает `true` если `value` было в множестве на момент вызова, иначе `false`.
- `set.has(value)` – возвращает `true`, если значение присутствует в множестве, иначе `false`.
- `set.clear()` – удаляет все имеющиеся значения.
- `set.size` – возвращает количество элементов в множестве.

### Перебор Set

- `set.values()` – возвращает перебираемый объект для значений
- `set.keys()` – то же самое, что и `set.values()`, присутствует для обратной совместимости с `Map`,
- `set.entries()` – возвращает перебираемый объект для пар вида `[значение, значение]`, присутствует для обратной совместимости с `Map`.
- `set.forEach` - тот же встроенный метод массивов, но второй аргумент - такой же как первый.

```js
// intersect can be simulated via
const intersection = new Set([...mySet1].filter(x => mySet2.has(x)))

// difference can be simulated via
const difference = new Set([...mySet1].filter(x => !mySet2.has(x)))
```
